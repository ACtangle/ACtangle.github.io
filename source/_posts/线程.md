---
title: 线程之synchronized详解
toc: true
date: 2020-01-02 17:40:47
thumbnail: /gallery/thumbnails/线程之synchronized详解.jpg
tags: java
categories: 笔记
---
#### 参考：https://www.imooc.com/learn/1086
#### 注意：笔记只对作者有用，不能保证可靠性
<!--more-->
* 1.互斥与同步的理解
```
线程互斥：多个线程竞争同一个锁条件
同步：指线程与线程之间的一种通信交互方式，一端发送消息、另一端响应消息
```
***
* 2.wait、notify、notifyAll的使用与理解
```
场景：多个线程在共享区域（临界区）抢占共享资源,获得锁才能进入临界区拿到对应的共享资源
共同点：都是实例的方法
wait：当前线程获取到锁对象，但是当前线程不满足某个条件时，就会释放当前占有的锁对象，最后当前线程放置于锁对象（记住是锁对象）中的wait set区域（等锁池），其他线程仍旧可以抢这个锁对象
notify与notifyAll：当其他线程已经抢占到锁对象并且执行完当前线程的某些操作，后使用notify和notifyAll唤醒锁对象中wait set区域内的单个或多个等待线程可以重新抢占锁对象
```
***
* 3.停止线程的方法stop(),interrupt()的使用注意事项。
```
1、基本放弃stop方法，容易导致死锁
2、interrupt方法可以用来请求线程终止，interupt实际是改变线程的某种状态（返回值是boolean值），如果线程被阻塞，就无法检测中断状态（在有join、sleep等方法操作的时候，造成Interrupted Exception异常中断）
3、如果需要真正切实可行的终结线程，一般采用一个boolean值在作为线程终结的标志来动态控制线程的结束
扩展：interrupted为静态方法，不同于interrupt方法，它是测试当前线程是否被终中断，副作用——将当前线程的中断状态置位false。
```
***
* 4.join（）、yield（）、sleep（）的区别
```
join：实例方法，其他线程需等待当前线程终止后（类似VIP插队）
yeild：Thread的静态方法，指当前线程让出处理器资源，其他线程包括当前线程重新竞争临界区（只会让给相同优先级或更高优先级的线程）
sleep：Thread的静态方法，线程休眠，但是不会释放对象锁（让给低优先级的线程）
扩展：sleep（）方法比yield（）方法更具有可移植性
```
***
* 5.线程六种状态。
```
New（新创建）、Runnable（可运行）、Blocked（被阻塞）、Waiting（等待）、Timed Waiting（计时等待）、Terminated（被终止）
~New：出一个新线程的时候的状态
~Runnable：调用start方法时，线程处于可运行状态，此时可运行的线程可能正在运行也可能没运行。一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权
~Blocked：
    1、当一个线程试图获取一个内部的对象锁时，但是此对象锁被其他线程持有，该线程进入阻塞状态。
    2、当线程等待另一个线程通知调度器一个条件时，它自己就会进入等待状态，比如使用Object的wait方法或者Thread的join方法，或者是等待java.util.concurrent中的Lock或者Condition时，就会出现这种情况（等待状态）
    3、有几个方法有一个超时参数。
```
***
* 6.对象锁和类锁
1.对象锁：对象锁指的是多个线程使用同一个实例(两种形式：代码块形式和方法形式)
```
synchronized (this) {
           ···
        }
```
```
此处形式实际上隐形的使用了this这个实例
public synchronized void method(){
           ···
    }
```
2.类锁：类锁指的是多个线程使用类的Class对象（唯一一个对象）（两种形式：静态方法）
```
public static synchronized void method(){
           ···
    }
```
```
synchronized (Abc.class) {
           ···
        }
```
注：类锁一般用于全局的情况下
***
* 7.synchronized有哪些特性，分别是什么？
```
可重入性：同一线程的外层函数获得锁以后，内层函数可以直接获取该锁，比如synchronized关键字（本质是由jvm跟踪对象锁加锁的次数，含有一个计时器）
假设synchronized不可重入，当有两个synchronized方法的前提下，同一线程在第一个方法（已获取锁对象）调用第二同步方法时，这个时候，当前方法持有锁，而第二个方法未持有锁，即会造成死锁情况。
不可中断性：锁一旦被占用就无法主动打断持有锁的线程，只能等待锁释放（不同于Lock类，Lock类具有中断和退出性质）
```
***
* 8.synchronized有哪些缺陷？
1.效率低：未持有锁的其他线程必须等待锁释放才能去获取临界资源，造成效率低
2.不够灵活（读写锁更灵活）：加锁和释放锁的时机单一，每个锁仅有单一的条件（对象），可能是不够的
3.无法知道是否成功获取锁
注意：以上可以当成Lock的相对缺陷，lock更灵活些是因为lock接口的某些方法，比如设置尝试获取锁trylock和它的参数设置超时时间以及它手动的lock加锁和unlock解锁操作；读写锁更灵活是因为读操作的时候可以不需要锁，写锁由于需要同步数据，所以必须要加入锁机制；掌握lock和synchronized的区别可以更细节的去根据业务场景进行选择
***




### 常问面试题
* 使用synchronized的注意事项？
1、锁对象不能为空（因为锁对象都是在对象里面的，可以参考javap -verpose反编译.class文件展开说monitorenter指令和monitorexit指令）
2、作用域不宜过大
3、避免死锁

* 如何选择synchronized关键字和Lock接口？
1、如果都满足业务需求，可以使用前者，因为代码量少避免出错
2、如果需要更灵活利用特性，比如lock的更为手动的灵活控制，就使用lock
3、如果有现成的已经实现现成安全的类则优先使用

* 多线程访问同步方法的各种情况
1、两个线程同时访问一个对象的同步方法 —— 同步串行（对象锁）
2、两个线程同时访问两个对象的同步方法 —— 并行（不同的对象锁）
3、两个线程访问的是synchronized静态方法 —— 同步串行（类锁）
4、同时访问同步方法和非同步方法 —— 非同步方法不会受到干扰
5、访问同一个对象的不同的普通同步方法 —— 同步（因为实际上的对象锁还是this当前实例）
6、同时访问静态synchronized和非静态synchroinzed方法 —— 并行（因为静态的同步方法访问类实例，而非静态同步方法访问的是类的Class对象，两个实例不一样，所以不存在竞争，即并行）
7、方法抛出异常，会释放锁 —— synchorinzed遇到异常会自动释放锁，而Lock需要trycatch后手动释放锁
8、如果多个线程去访问一个被synchronized关键字的方法（这个方法会去调用非synchronized的方法），此时线程是不安全的，因为当调用的方法脱离了synchronized之后，就脱离了该关键字的范围