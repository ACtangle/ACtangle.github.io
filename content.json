{"pages":[{"title":"about","text":"关于小瓜仔从始至终,重新出发","link":"/about/index.html"}],"posts":[{"title":"redis之锁相关知识和场景","text":"注意：笔记只对作者有用，不能保证可靠性 1.加锁方法目的：解决死锁问题场景：商品秒杀，key为商品id，value为当前时间和超时时间内容：某一个时间点上，多个用户秒杀某个商品，其中开启了多个线程去处理，可能造成多个线程内有某个线程获取锁后由于其他方面如网络堵塞造成锁无法释放，使得时间超时，这个时候应该解锁，不能造成死锁。关键点：1.锁只能被单个线程占用；2.当两个线程同时进入加锁方法时且进入到锁过期代码段，则只能有一个线程会去跑redisTemplate.opsForValue().getAndSet(key,value)这段代码3.getAndSet方法获取的是上个占用锁的时间，且将当前进入该代码段的线程的value置位改key新的value值，所以当第二个线程进来时，原先的value已经被修改了，则判断不相等。12345678910111213141516171819202122/** * key为商品id,value为当前时间+超时时间 */public boolean lock(String key, String value) { //如果不存在则可以加锁判断为true返回为true if(redisTemplate.opsForValue().setIfAbsent(key,value)){ return true; } //获取上一次占用锁的value值，方便理解这里使用时间 String currentValue = redisTemplate.opsForValue().get(key); //如果锁过期了 if(!StringUtils.isEmpty(currentValue) &amp;&amp; Long.parseLong(currentValue) &lt; System.currentTimeMillis()) { //获取上一个锁的时间 String oldValue = redisTemplate.opsForValue().getAndSet(key,value); if(!StringUtils.isEmpty(oldValue) &amp;&amp; oldValue.equals(currentValue)) { return true; } } return false;} 1.释放锁目的：释放占用的锁场景：释放锁内容：拿到当前的时间值与redis的value值对应，相等则删除redis对应key释放锁关键点：释放锁1234567891011121314/** * 拿到当前的value值与redis对应key的值作比较，相等则删除，否则抛异常 */public void unlock(String key,String value) { try{ String currentValue = redisTemplate.opsForValue().get(key); if(StringUtils.isEmpty(currentValue) &amp;&amp; currentValue.equals(value) { redisTemplate.opsForValue().getOperations().delete(key); } }catch(Exception){ log.error(&quot;[redis分布式锁机制]解锁异常:{}&quot;,e); } }","link":"/2020/01/02/redis/"},{"title":"spring事务基础认识和配置","text":"注意：笔记只对作者有用，不能保证可靠性 事务的特性：原子性、隔离性、持久性、一致性 Spring为不同的框架提供了不同PlatformTransactionManager接口（事务管理器）的实现类 TransactionDefinitions定义事务隔离级别（隔离级别为了解决脏读、幻读、不可重复读这几类问题），spring默认提供隔离级别为default，即后端系统使用的数据库默认的隔离级别 事务的传播行为：为了解决业务层方法（都有事务）之间相互调用的问题 重点可看1、4、7行为类型，各属三大类：以下为图中的讲解：1、第一类（在同一个事务内）： 第一种：先到达a事务的方法如果存在就使用a的事务，如果a不存在事务，b存在事务就使用b事务 第二种：先到达a事务的方法如果存在就使用a的事务，如果a不存在事务b就不使用事务 第三种：先到达a事务的方法如果存在就使用a的事务，如果a不存在事务就抛出异常2、第二类（不在同一个事务内）： 第四种：如果a事务存在，就挂起当前事务，创建一个新的事务，此时a和b不在一个事务内3、第三类（事务a后再事务b）： 第七种：如果当前a事务存在，就使用嵌套事务 TransactionStatus接口（事务状态）：获得或者判断事务的状态方法 编程式事务管理：通过配置transactionTemplate然后在业务层引入该bean去实现每个业务方法的回滚； 声明式事务有三种方式： 1、基于AOP面向切面：通过配置代理类扩充业务类来实现动态代理，第二种与第一种的区别是第一种需要在业务层的方法内去手动变成，而第二种是在业务类引入业务类的代理类来统一业务的方法回滚（不常用，因为实际开发中对代理类的配置会很多） 2、基于AspectJ的xml的配置：无须再业务类内引入代理类，自动生成（常用） 1）配置事务增强 2）配置切面 3、基于注解方式的配置：（常用，最简单使用） 第二种配置后不用再业务层上增加代码，而第三种需要增加注解，看业务场景都可以使用","link":"/2020/01/02/spring%E4%BA%8B%E5%8A%A1/"},{"title":"反射之基础使用","text":"注意：笔记只对作者有用，不能保证可靠性 所有抽象出来的类都是java.lang.Class类中的一个对象（细品），这个对象称为该类的类类型，一个类只有一个Class类的实例对象，即只有一个类类型以下为Class的使用：123456789101112131415161718Foo foo1 = new Foo();//第一种方式Class c1 = Foo.class;//第二种方式Class c2 = foo1.getClass();//第三种方式Class c3 = null;try { c3 = Class.forName(&quot;refelect.demo.Foo&quot;);}catch (ClassNotFoundException e){ e.printStackTrace();}//一个抽象的类只可能是Class类的一个实例对象（细品）System.out.println(c1 == c2); //true 12345678//通过类类型来创建类的实例对象try { Foo foo = (Foo) c1.newInstance(); //需要有无参构造方法} catch (InstantiationException e) { e.printStackTrace();} catch (IllegalAccessException e) { e.printStackTrace();} 动态加载类编译时刻是静态加载类（new的时候），把一切可能用到或者用不到的类全部静态加载，而动态加载不一样，是发生在运行时刻的假设一个程序有100方法，但是只要有一个类无法静态加载时，整个程序崩溃造成其他99个都无法使用，这显然不符合业务需求，当我们需要用到某个方法时，我们希望，即需即创建和使用，这样更灵活，这就是运行时期动态加载的好处（Class.forName方法代表了动态加载类） 基本数据类型void 关键字 都存在类类型 —&gt; void.classint\\double 都存在类类型 —&gt; int\\double.class注意：double数据类型和Double类的类类型不同 ArrayList和ArrayList的类类型一样吗是一样的重点：Java集合中的泛型是为了防止错误输入的，只在编译阶段有效（重点），可以使用返回在运行时期向ArrayList中添加不是String类型的数据，如果添加了非泛型类型的数据就不能使用foreach来遍历，会报错综上：反射是绕开编译时期来进行的","link":"/2020/01/02/%E5%8F%8D%E5%B0%84/"},{"title":"我的2019","text":"甘为思想容器却缺乏执行力的定时炸弹 # 失业失业已经连续七个月多了，期间焦虑过，挣扎过，站起来过，但是终究适应了麻木。当然，这都是自食其果，我全都知道。今年是半收获的一年，在上家学到了不少东西，也清楚自己的能力定位，但是始终不清楚是否适合在该行业生存得下去，于是一直逃避，一直视若无睹，终究，被现实压垮了。不敢面见身边的人，不敢让朋友家人们知道我的状态，但只有我知道，我一直想的是如何死亡，而身体本能告诉我不能这样做，于是为了抵抗这股邪恶势力，我设下了很多期待，但代价是负债累累。如果你问我为什么失业，我告诉你，仅仅是因为我害怕，我害怕任何工作上的错误和社会的职场套路。 # 拖拉无可否认的是，懒惰造成了现在的局面，始终认为在以后某个时间点，以后某个地方，一定能弥补现在所有的代价与不足，而现实是，接踵而来无数次面对低谷的夜晚，不断被拒绝的简历回复，我不为任何事情找借口，你可以称之为颓废。我开始想象死亡，尊敬死亡，只是主动死亡并不可能，我更希望有一次意外且完美的死亡，可以让大家释怀却无能为力地死亡，当然我知道，这不可能，很抱歉，太多繁杂有用无用的信息都在脑子里，仿佛它告诉你可以这样却有另外一个声音说不可以。 # 希望如此丧，心中却一直充满希望，希望我可以成为一个热血的人，一个骑士，一个本来大家都可以认为我做到的人，只是现在朋友们评价我，总是以惨字开头，只是现在，我突然害怕我做不到。总是号令着改变，却从没有执行，这很现实。但我相信只要活着，总能有办法的吧。 # 思想无数个控制不住的熬夜，无数个思想，脑袋里像是个容器，有吸无收，世界观，价值观，人生观基本被坍塌，被冲刷。 # 经济负债累累，却为了对生活有更大的期待，购入一批数码产品，有最新的airpods pro，iwatch等，我知道，在失去了收入却还要购买的行为很可耻，也很贱，但是确实对我一点点帮助，只是去年以为今年可以购入macbook pro，还是落空了，希望明年当一个正常人吧。 # 2020计划 债务偿还 新入macbook pro 阅读，养身体 当一个正常职业者 出去走一走，看看这个世界 负重前行吧。","link":"/2020/01/08/%E6%88%91%E7%9A%842019/"},{"title":"线程之synchronized详解","text":"参考：https://www.imooc.com/learn/1086注意：笔记只对作者有用，不能保证可靠性 1.互斥与同步的理解12线程互斥：多个线程竞争同一个锁条件同步：指线程与线程之间的一种通信交互方式，一端发送消息、另一端响应消息 2.wait、notify、notifyAll的使用与理解1234场景：多个线程在共享区域（临界区）抢占共享资源,获得锁才能进入临界区拿到对应的共享资源共同点：都是实例的方法wait：当前线程获取到锁对象，但是当前线程不满足某个条件时，就会释放当前占有的锁对象，最后当前线程放置于锁对象（记住是锁对象）中的wait set区域（等锁池），其他线程仍旧可以抢这个锁对象notify与notifyAll：当其他线程已经抢占到锁对象并且执行完当前线程的某些操作，后使用notify和notifyAll唤醒锁对象中wait set区域内的单个或多个等待线程可以重新抢占锁对象 3.停止线程的方法stop(),interrupt()的使用注意事项。12341、基本放弃stop方法，容易导致死锁2、interrupt方法可以用来请求线程终止，interupt实际是改变线程的某种状态（返回值是boolean值），如果线程被阻塞，就无法检测中断状态（在有join、sleep等方法操作的时候，造成Interrupted Exception异常中断）3、如果需要真正切实可行的终结线程，一般采用一个boolean值在作为线程终结的标志来动态控制线程的结束扩展：interrupted为静态方法，不同于interrupt方法，它是测试当前线程是否被终中断，副作用——将当前线程的中断状态置位false。 4.join（）、yield（）、sleep（）的区别1234join：实例方法，其他线程需等待当前线程终止后（类似VIP插队）yeild：Thread的静态方法，指当前线程让出处理器资源，其他线程包括当前线程重新竞争临界区（只会让给相同优先级或更高优先级的线程）sleep：Thread的静态方法，线程休眠，但是不会释放对象锁（让给低优先级的线程）扩展：sleep（）方法比yield（）方法更具有可移植性 5.线程六种状态。1234567New（新创建）、Runnable（可运行）、Blocked（被阻塞）、Waiting（等待）、Timed Waiting（计时等待）、Terminated（被终止）~New：出一个新线程的时候的状态~Runnable：调用start方法时，线程处于可运行状态，此时可运行的线程可能正在运行也可能没运行。一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权~Blocked： 1、当一个线程试图获取一个内部的对象锁时，但是此对象锁被其他线程持有，该线程进入阻塞状态。 2、当线程等待另一个线程通知调度器一个条件时，它自己就会进入等待状态，比如使用Object的wait方法或者Thread的join方法，或者是等待java.util.concurrent中的Lock或者Condition时，就会出现这种情况（等待状态） 3、有几个方法有一个超时参数。 6.对象锁和类锁 1.对象锁：对象锁指的是多个线程使用同一个实例(两种形式：代码块形式和方法形式) 123synchronized (this) { ··· } 1234此处形式实际上隐形的使用了this这个实例public synchronized void method(){ ··· } 2.类锁：类锁指的是多个线程使用类的Class对象（唯一一个对象）（两种形式：静态方法） 123public static synchronized void method(){ ··· } 123synchronized (Abc.class) { ··· } 注：类锁一般用于全局的情况下 7.synchronized有哪些特性，分别是什么？123可重入性：同一线程的外层函数获得锁以后，内层函数可以直接获取该锁，比如synchronized关键字（本质是由jvm跟踪对象锁加锁的次数，含有一个计时器）假设synchronized不可重入，当有两个synchronized方法的前提下，同一线程在第一个方法（已获取锁对象）调用第二同步方法时，这个时候，当前方法持有锁，而第二个方法未持有锁，即会造成死锁情况。不可中断性：锁一旦被占用就无法主动打断持有锁的线程，只能等待锁释放（不同于Lock类，Lock类具有中断和退出性质） 8.synchronized有哪些缺陷？ 1.效率低：未持有锁的其他线程必须等待锁释放才能去获取临界资源，造成效率低2.不够灵活（读写锁更灵活）：加锁和释放锁的时机单一，每个锁仅有单一的条件（对象），可能是不够的3.无法知道是否成功获取锁注意：以上可以当成Lock的相对缺陷，lock更灵活些是因为lock接口的某些方法，比如设置尝试获取锁trylock和它的参数设置超时时间以及它手动的lock加锁和unlock解锁操作；读写锁更灵活是因为读操作的时候可以不需要锁，写锁由于需要同步数据，所以必须要加入锁机制；掌握lock和synchronized的区别可以更细节的去根据业务场景进行选择 常问面试题 使用synchronized的注意事项？1、锁对象不能为空（因为锁对象都是在对象里面的，可以参考javap -verpose反编译.class文件展开说monitorenter指令和monitorexit指令）2、作用域不宜过大3、避免死锁 如何选择synchronized关键字和Lock接口？1、如果都满足业务需求，可以使用前者，因为代码量少避免出错2、如果需要更灵活利用特性，比如lock的更为手动的灵活控制，就使用lock3、如果有现成的已经实现现成安全的类则优先使用 多线程访问同步方法的各种情况1、两个线程同时访问一个对象的同步方法 —— 同步串行（对象锁）2、两个线程同时访问两个对象的同步方法 —— 并行（不同的对象锁）3、两个线程访问的是synchronized静态方法 —— 同步串行（类锁）4、同时访问同步方法和非同步方法 —— 非同步方法不会受到干扰5、访问同一个对象的不同的普通同步方法 —— 同步（因为实际上的对象锁还是this当前实例）6、同时访问静态synchronized和非静态synchroinzed方法 —— 并行（因为静态的同步方法访问类实例，而非静态同步方法访问的是类的Class对象，两个实例不一样，所以不存在竞争，即并行）7、方法抛出异常，会释放锁 —— synchorinzed遇到异常会自动释放锁，而Lock需要trycatch后手动释放锁8、如果多个线程去访问一个被synchronized关键字的方法（这个方法会去调用非synchronized的方法），此时线程是不安全的，因为当调用的方法脱离了synchronized之后，就脱离了该关键字的范围","link":"/2020/01/02/%E7%BA%BF%E7%A8%8B/"},{"title":"计算机网络之基础知识","text":"出处：https://juejin.im/post/5d896cccf265da03bd055c87#heading-0注意：笔记只对作者有用，不能保证可靠性 应用层：应用层的任务是通过应用程序间的交互来完成特定网络应用，互联网中应用层协议有很多比如域名系统DNS，支持万维网应用的HTTP协议等，应用层交互的数据单元称为报文。 运输层：运输层的任务是负责向两台主机的进程之间的通信提供通用的据传输服务，应用程序通过该服务传送应用报文。 网络层：网络层的任务是选择合适的网间路由和交换节点，确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组和包进行传送，在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也称为IP数据报，简称数据报。 数据链路层：两台主机之间的数据传输，总是在一段一段的链路上送的，这就需要专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层会将网络层交下来的IP数据报组装成帧，在两个相邻节点之间传送帧。每一帧都包括数据和必要的控制信息。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。 物理层：物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 IP地址分类：指互联网协议地址，是IP地址协议的统一的地址格式，分为A、B、C、D、E五类，ABC是基本类，DE为特殊地址，作为多播和保留使用。每个IP地址包括两个标识码（ID)，即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机有一个主机ID与其对应。123456A-E类地址：A：以0开头，第一个字节范围为：0~127B：以10开头，第一个字节范围：128~191C：以110开头，第一个字节范围：192~223D：以1110开头，第一个字节范围为 224~239E：以1111开头，保留地址 TCP的主要特点：123451.TCP是面向连接的（比如打电话，需要先拨号连接，通话结束后要挂机释放）2.每一条TCP都有两个端点，也就是只能一对一，点对点3.TCP提供可靠交付的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，并且按顺序到达4.TCP提供全双工通信，即通信双方任何时候都能发送数据，因为两个端都设有发送缓存和接收缓存5.面向字节流 UDP的主要特点：1234561.UDP是无连接的2.UDP不保证可靠交付3.UDP面向报文4.UDP没有拥塞控制，因此发送速率不会降低（实时、直播有用）5.UDP支持一对一、一对多、多对一和多对多的交互通信6.UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短 三次握手：1（A向B尝试TCP连接）第一次握手时A向B发送报文发送SYN为1的首部，由于SYN为1时，必须消耗掉一个序号seq（seq=x），A进程就进入同步已发送状态；第二次握手时B收到连接请求报文后，如果同意建立连接，则向A发送确认。这时SYN置为1，ACK置为1，同理也要消耗掉一个seq（seq=y），确认号ack置为x+1，此时B进程进入同步收到状态；第三次握手，A收到B的确认后，还需要告知B已得到B的确认，所以将ACK置为1，确认号ack=y+1，seq置为x+1，ACK可以携带数据。（ACK如果不携带数据，下一个数据报文段的seq就为x+1），这时，TCP连接就建立完成了，A进入已建立连接状态。 为什么两次握手不可以满足？1比如A客户进程向B服务器进程发送了连接请求，但是由于网络问题，发送给B的报文延迟了，而在这之前，连接已被释放，B就会误以为这是一次新的连接，假如此时只有两次握手，那么B收到报文后就返回确认，并且与A建立连接，但是实际上A并没有发送实际的请求，这就会导致A与B一直持续连接，B一直等待A发送数据，造成资源浪费。但是如果使用了三次握手，A在实际上并没有建立连接请求的前提下，不会理睬B的确认同步，也不会向A发送数据，B收不到A的确认就不会建立连接。 为什么不使用四次握手？1有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。 TCP四次挥手123456TCP四次挥手发生在数据传输结束后，通信双方释放连接的时候，假设此时A客户机进程和B服务器进程处于连接状态。第一次握手：A进程向TCP发出连接释放请求，主动关闭TCP连接，将连接释放的控制首部FIN置为1，并消耗一个序号seq=u，等待B的确认。第二次握手：B进程收到连接释放报文后立即发出确认，确认号是ack=u+1，将ACK置为1，同时也消耗一个序号seq=v。此时A到B的连接的方向就释放了，但是B到A的连接并没有释放，也就是此时A仍需要等待B发出的连接释放报文段，处于半关闭状态第三次握手：若B已经没有向A发送的数据，其应用程序就通知TCP释放连接，这时B的FIN为1，序号为w，确认号ack=u+1。此时还需等待A的确认第四次握手：A在收到B的释放连接报文后，必须响应给B确认，即将ACk置为1，确认号ack=w+1，而序号seq为u+1，进入时间等待状态。注意，此时TCP仍没有释放，必须经过时间等待计时器设置的时间2MSL（MSL：最长报文寿命）后，A才能进入CLOSED状态，然后撤销传输控制块，结束这次TCP连接。当然B一旦接受到A的确认就立即进入CLOSED状态，然后撤销传输控制块。注意：第四次握手中，B结束TCP的连接要早于A 为什么第四次挥手要等待2MSL的时间？12为了保证第四次握手最后一个ACK报文能够到达B。因为B传最后一个ACK报文的时候，ACK报文可能丢失，如果不经过2MSL（超时+1MSL的传输），B收不到这个报文段，会重新传一次FIN+ACK报文给A，而此时A已经释放了，A就得不到B对A的确认报文，A就不会重新发送ACK报文段给B，B就会无法释放。 四次挥手中为什么第二次和第三次无法合并？1因为第二次握手中，客户端不会再向服务端请求任何数据，但是服务端可能还在向客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前的数据传输完毕后再发送关闭请求 保活计时器的作用场景：客户端与服务端已建立了TCP连接，但是此时客户机已经故障，服务端却不知情，就会白白等待下去，浪费资源，这时候就需要保活计时器作用：服务端每收到一次客户端的数据，就会重新设置保活计时器的时间，一般为两个小时。若两个小时都没有收到客户端发送的数据，服务端就会发送一个探测报文，以后每隔75秒发送一次。若10个探测报文仍无法收到客户端的响应，服务端就认为客户端出了故障，就关闭这个连接。 TCP是如何保证可靠传输的？ 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；2. 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 什么是粘包？12345如果客户端不断向服务端发送数据包，服务端接受的数据会出现两个包粘在一起的情况。1.TCP是面向字节流的，虽然应用层和TCP之间的数据交互是大小不等的数据包，但是TCP吧这些数据块仍看成一连串无结构的字节流，没有边界。2.从TCP的帧结构可以看出来，TCP的首部没有表示数据长度的字段。由此可以从上面两点可以知道，使用TCP传输数据时，才有粘包和拆包现象的发生的可能性，一个数据包中包含了发送端发送的两个数据包的信息，称为粘包。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么是多出来一块，这种情况就是发生了粘包和拆包。粘包和拆包的问题导致服务端在处理的时候非常困难，因为无法区分一个完整的数据包。 TCP黏包是怎么产生的？ 1.发送端产生粘包：采用TCP协议时一般都是处于长连接的状态下（一次连接发一次数据不存在粘包），当发送的数据包过于的小时，TCP协议默认会使用Nagle算法，将这些较小的数据包进行合并发送；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。2.接收端产生粘包：接收端接受数据在网络层模型自下向上，所以数据被运输层的TCP协议放置接收缓冲区，接下来应用层调用函数来从缓冲区取数据，但是并不能保证函数能及时的将缓冲区的数据拿出来，而下一个数据又到来的时候并有一部分放入了缓冲区末尾，造成一个粘包。（放数据的速度&gt;取数据的速度） 如何解决粘包和拆包？12341.特殊字符控制2.在包头首部添加数据包的长度如果使用netty的话，就会使用专门的编码器和解码器解决粘包和拆包的问题tips：UDP没有粘包问题，因为是面向报文的，但是会丢包和乱序，不完成的包是不会有的，收到的都是正确的包。传送的数据单位协议UDP报文或用户数据报，发送的时候既不会合并，也不拆分。 forward和redirect的区别？ 1.直接转发（forward）：客户端和浏览器只发出一次请求，Servlet、Html、Jsp或其他信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。2.间接转发（redirect）：实际上的两次http请求，服务器端响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。 GET和POST的区别本质区别：GET只是一次HTTP请求，POST先发请求头再发请求体，实际上是再次请求。1231.GET一般用来获取服务器资源（幂等性），POST请求一般用来更新服务器资源2.GET安全性低于POST，因为它会将数据以明文的形式展现在URL上，而POST请求参数被包装到请求体内3.GET请求的长度受限于浏览器或服务器对URL长度的限制，而POST则请求没有大小限制 在浏览器输入URL地址到显示主页的请求过程1234561.DNS解析：通过DNS解析获取域名对应的IP地址2.TCP连接：浏览器向服务器请求建立连接，三次握手3.发送HTTP请求：TCP连接建立后，浏览器向服务器发送HTTP请求4.服务器处理请求并返回HTTP报文：服务器接收到这个请求，根据路径和参数映射到指定的处理器进行处理，并将处理结果及相应的视图返回给浏览器5.浏览器解析渲染页面：浏览器解析并渲染页面6.连接结束（四次挥手） 谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。","link":"/2020/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"java面试题目 -- 持续更新","text":"注意：笔记只对作者有用，不能保证可靠性请简述SpringMVC的工作流程? 用户发起请求到前端控制器（DispatcherServlet），该控制器会过滤出哪些请求可以访问Servlet、哪些不能访问。就是url-pattern的作用，并且会加载springmvc.xml配置文件。 前端控制器会找到处理器映射器（HandlerMapping），通过HandlerMapping完成url到controller映射的组件，简单来说，就是将在springmvc.xml中配置的或者注解的url与对应的处理类找到并进行存储，用map&lt;url,handler&gt;这样的方式来存储。 HandlerMapping有了映射关系，并且找到url对应的处理器，HandlerMapping就会将其处理器（Handler）返回，在返回前，会加上很多拦截器。 DispatcherServlet拿到Handler后，找到HandlerAdapter（处理器适配器），通过它来访问处理器，并执行处理器。 执行处理器 处理器会返回一个ModelAndView对象给HandlerAdapter 通过HandlerAdapter将ModelAndView对象返回给前端控制器(DispatcherServlet) 前端控制器请求视图解析器(ViewResolver)去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)，其实就是将ModelAndView对象中存放视图的名称进行查找，找到对应的页面形成视图对象 返回视图对象到前端控制器。 视图渲染，就是将ModelAndView对象中的数据放到request域中，用来让页面加载数据的。 通过第8步，通过名称找到了对应的页面，通过第10步，request域中有了所需要的数据，那么就能够进行视图渲染了。最后将其返回即可。 请简述一下mybatis中，Collection和Association标签的区别？ assocation表示一对一和多对一的情况，比如一个Person类包含一个Card类，因为一个人对应一个身份证，这里是一对一的情况 Collection表示的是一对多的情况。 一对一： 12345678910&lt;resultMap type=&quot;com.glj.poji.Person&quot; id=&quot;personMapper&quot;&gt;&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;&lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;&lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;&lt;association property=&quot;card&quot; column=&quot;card_id&quot;select=&quot;com.glj.mapper.CardMapper.selectCardById&quot;javaType=&quot;com.glj.poji.Card&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt; 一对多： 123456789101112131415161718&lt;resultMap type=&quot;com.glj.pojo.Clazz&quot; id=&quot;clazzResultMap&quot;&gt;&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;&lt;result property=&quot;code&quot; column=&quot;code&quot;/&gt;&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;&lt;!-- property: 指的是集合的属性, column指的是数据库字段，ofType：指的是集合中元素的类型 --&gt;&lt;collection property=&quot;students&quot; ofType=&quot;com.glj.pojo.Student&quot;column=&quot;id&quot; javaType=&quot;ArrayList&quot;fetchType=&quot;lazy&quot; select=&quot;com.glj.mapper.StudentMapper.selectStudentByClazzId&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;&lt;/collection&gt;&lt;/resultMap&gt; 多对一： 1234567891011&lt;resultMap type=&quot;com.glj.pojo.Student&quot; id=&quot;studentResultMap&quot;&gt;&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;&lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;&lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt;&lt;association property=&quot;clazz&quot; javaType=&quot;com.glj.pojo.Clazz&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;code&quot; column=&quot;code&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;&lt;/association&gt;&lt;/resultMap&gt; 请简述下Bean注入属性有几种方式，分别是什么？由于spring的特性：DI（依赖注入），控制反转Spring容器中支持的依赖注入方式主要有属性注入、构造函数注入、工厂方法注入。 属性注入：即通过setXXX( )方法注入bean的属性值或依赖对象。由于属性注入方式具有可选择性和灵活性高的特点，因此它也是实际开发中最常用的注入方式。对于属性注入方式来说，只能人为的在配置文件中提供保证，而无法在语法级别提供保证。 例如：这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口） 123456789101112package com.bless.springdemo.action; public class SpringAction { //注入对象springDao private SpringDao springDao; //一定要写被注入对象的set方法 public void setSpringDao(SpringDao springDao) { this.springDao = springDao; } public void ok(){ springDao.ok(); } } 随后编写spring的xml文件中，name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在标签中创建一个标签指定SpringDao。标签中的name就是SpringAction类中的SpringDao属性名，ref指下面，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入： 123456&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt; &lt;property name=&quot;springDao&quot; ref=&quot;springDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; 构造函数注入：除属性注入之外的另一种常用的注入方式，它可以保证一些必要的属性在bean实例化时就得到了设置，并在实例化后就可以使用。构造函数注入的前提是： bean必须提供带参的构造函数。 这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来： 1234567891011121314151617public class SpringAction { //注入对象springDao private SpringDao springDao; private User user; public SpringAction(SpringDao springDao,User user){ this.springDao = springDao; this.user = user; System.out.println(&quot;构造方法调用springDao和user&quot;); } public void save(){ user.setName(&quot;卡卡&quot;); springDao.save(user); } } 在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt; &lt;constructor-arg ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;user&quot; class=&quot;com.bless.springdemo.vo.User&quot;&gt;&lt;/bean&gt; Spring工厂注入：可以分为 静态 和 非静态 两种。 构造函数注入选择理由： 构造函数保证重要属性预先设置；无需提供每个属性的setter方法，减少类的方法个数；可以更好地封装类变量，避免外部错误调用。 属性注入选择理由： 属性过多时，构造函数变的臃肿；构造函数注入灵活性不强，有时需要为属性注入null值；多个构造函数时，配置上产生歧义，复杂度升高；构造函数不利于类的继承和扩展；构造函数注入会引起循环依赖的问题。 其实Spring为我们注入参数提供了这么多方法，那么这些方法必然有他们存在的道理，每个方法在某一问题上会有独特的优势，我们只需要按照我们具体的使用需求选择适合的方法来使用就好了，但一般不太推荐工厂方法注入。 请简述一下SpringMVC中，@RequestBody和@ResponseBody的区别？ @RequestBody：将前台的key，value数据data：name=“1”&amp;id=1 或者json数据data ：{name：“1”，id：1 } 转换成java对象入形参。 @ResponseBody：将返回到前台的java对象 转换成json串输出。 两个注解都是用于数据格式和pojo对象之间的转换** 请说一下，mybatis中#和@的区别？ #{}可以防止sql注入，它是一种预编译的语句，即在使用jdbc时的prepareStatement，sql如果存在参数则会使用?占位符，使用#{}形成的sql语句，是带有引号的。比如select * from table1 where id = #{id}中实际上的select * from table1 where id = ‘1’，另外，使用xml配置时只能使用#{}语法，而且，当parameterType是int时，必须使用该语法。 使用${}形成的sql语句没有被引号包裹，但是在以下sql语句时最好使用该语句：select ‘table1’ order by ‘id’表示按哪个表和按某个列排序时 请说一下事务的管理机制是什么？可以查看Spring事务笔记模块 请简述下SpringMVC主要使用了哪些设计模式？ 简单工厂模式，例如BeanFactory 工厂方法模式 适配器模式 包装器模式 代理模式 观察者模式 策略模式 模板方法模式 Spring如何保证Controller并发的安全？Spring中controller默认是单例模式，如果加注解@Scope(prototype)则为多例模式，Spring多线程访问的都是一个controller，如果controller中含有类变量，那所有的请求都会共享这个变量，可能出现于预期的值不一样。可以用多例模式解决，但是使用多例模式会产生时间的开销。最好的解决方案是：使用ThreadLocal来保存类变量，将类变量保存在线程的变量域中，让不同的请求隔离开来。ThreadLocal会为每一个线程提供一个独立的变量副本 ThreadLocal Spring Bean的生命周期是如何管理的？ 实例化bean对象(通过构造方法或者工厂方法) 设置对象属性(setter等)（依赖注入） 如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口） 如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身 将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法 调用Bean的初始化方法 将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法 使用Bean 容器关闭之前，调用Bean的销毁方法 总结就四步骤，实例化，属性赋值，初始化，销毁 “a==b”和“a.equals(b)”有什么区别？ “a==b”指的是对象的引用，只有当两个引用都指向堆中的同一个对象时才返回true “a.equals(b)”指的是内容的比较，当内容相等时候返回true，这里指的是逻辑一致性的比较。例如，String类需要重写equals方法，可以用于两个不同的对象，但是内容相等的比较 HashMap是线程安全的吗？为什么不是线程安全？HashMap底层是一个entry数组，当发生哈希碰撞时，HashMap会采用链表的方式解决，在对应的数组位置上存放链表的头结点，然后新加入的节点会从改头结点加入，而此过程是非同步的。如果多个线程同时访问一个HashMap，在访问同一个hash映射的同时对映射关系进行结构上的修改，会造成不同步的现象。 HashMap不是线程安全的，发生在多线程对同一个HashMap加入时，HashMao结构的变化，一般指的是Resize（包含扩容，ReHash），ReHash在并发的情况下回形成闭环。 HashMap,ConcurrentHashMap与LinkedHashMap HashMap线程不安全，无序 ConcurrentHashMap采用分段锁方式进行数据同步，但是因为进行两次哈希算法（第一次确定该元素位于哪一个段即segment，第二次确定元素位置），因此效率相比于HashMap要低，但是在多线程的情况下满足一定的线程安全场景（牺牲性能换取数据安全） LinkedHashMap维护一个双链表，可以按数据的写入顺序读出 注意：这里ConcurrentHashMap指的是在一个段(segment)内线程安全，分配的锁作用于段上。应用场景是高并发，但是不能保证完全的线程安全 如何创建一个线程，有哪几种方式，他们的区别是什么？ 自定义Thread的子类，并重写父类的run方法即执行体，然后创建Thread的实例，调用实例的start方法 自定义类实现Runnable接口，并重写run方法，然后使用new Thread()并注入自定义类对象，接着低啊用start方法 通过Callable和Future创建线程 使用runnable和Callable接口的优势是可以多实现，还可以继承其他类使用Thread子类继承的方式的优势是无需使用Thread.currentThread访问当前的线程，而只需要使用this即可 wait和sleep的区别 wait是Object对象上的方法，在同步代码块或者同步方法中使用，会释放当前的同步锁，让出cpu，进入等待状态，可以用notify和notifyAll方法唤醒 sleep是Thread的静态方法，可以在任何地方使用，必须捕获异常，不会释放锁，可以使用interrupt方法唤醒 请描述一下HashMap的扩容过程当HashMap填满了0.75负载因子的桶（bucket）时才会发生扩容: HashMap.size()&gt; Capacity(容量) * loadFactor(负载因子) —— Resize 扩容: 创建一个新的entry空数组，长度是原数组的两倍 Rehash: 因为长度不一样，哈希计算的值也不一定，遍历原来的entry数组，把所有的entry数组重新hash到扩容的数组上 请说一下强引用、软引用、弱引用、虚引用分别是什么？ 强引用：一般是new出来的对象，垃圾回收器是不会回收强引用类型的对象，即使当程序抛出OutMemoryError错误也不会回收具有强引用的对象。如果想让强引用对象回收，可以认为设置对象为null让垃圾回收器GC回收 软引用：当内存充足时不会进行垃圾回收，当内存不足时则会进行垃圾回收。当内存不足时，JVM优先对软引用设置为null，再进行垃圾回收 弱引用：不管内存是否充足，都会回收软引用对象的内存。不过由于软引用是一个优先级很低的引用，所以不一定很快就会发现软引用 虚引用：虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收 synchronize在静态方法和普通方法的区别？ 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象 如何处理HashMap的并发问题？使用ConcurrentHashMap 线程池的种类有哪些，他们的区别和使用场景？ newCachedThreadPool： 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列) 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。 适用：执行很多短期异步的小程序或者负载较轻的服务器 newFixedThreadPool： 底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue() 无解阻塞队列 通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列) 适用：执行长期的任务，性能好很多 newSingleThreadExecutor: 底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue() 无解阻塞队列 通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列) 适用：一个任务一个任务执行的场景 NewScheduledThreadPool: 底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列 通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构 索引使用的注意条件可以大概说几个吗？为什么有时候索引会失效？ 当sql语句使用了计算表达式（例如&lt;&gt; 、not in 、not exist、!=）、函数运算、正则表达式和like关键字字符串前有%不会使用索引 当等值查询时值为数字时不会使用索引，值为字符串时会使用索引 使用or语句索引失效，有且仅当or条件的所有列都加上索引才不会失效 什么是悲观锁、乐观锁、排它锁、共享锁？他们的应用场景是什么？ 乐观锁：总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。核心SQL代码： 1update table set x=x+1, version=version+1 where id=#{id} and version=#{version}; CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。 乐观锁一般乐观锁只用在高并发、多读少写的场景。 悲观锁： 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁。共享锁、排它锁都是悲观锁。一旦通过悲观锁锁定一个资源，那么其他需要操作该资源的使用方，只能等待直到锁被释放，好处在于可以减少并发，但是当并发量非常大的时候，由于锁消耗资源，并且可能锁定时间过长，容易导致系统性能下降，资源消耗严重。 在并发量不是很大，并且出现并发情况导致的异常用户和系统都很难以接受的情况下，会选择悲观锁进行 共享锁：也称为读锁，对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后。语法为： 1select * from table lock in share mode 排他锁：也称为写锁，对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。语法为： 1select * from table for update ———— 增删改自动加了排他锁 数据库的增删改操作默认都会加排他锁，而查询不会加任何锁 左连接、右连接、内连接的区别是什么？ 左外连接：根据左表为主，查出左表关于右表的所有数据，包括null 右外连接：根据右表为主，查出右表关于左表的所有数据，包括null 内连接：也是自然连接，显示左表和右表共有的，即交集 注意：使用join外连接的时候，在一般业务上如果不考虑性能问题的话就可以使用join，但是在数据量特别大而且关联表特别多（超过三表），，建议将关联的逻辑放在业务层实现，即在业务三次查询避免join连接。因为当数据量特别大的时候，数据库会使当次查询的时间缩短。在分库分表的情况下，join难以跨库查询，所以在业务量大的情况下使用业务层逻辑避免使用join连接 事务并发会出现什么问题？请举一个他们的例子？事务并发会出现以下四种问题：脏读、丢失修改、不可重复读、幻读 脏读：假设A事务已修改了数据但是为提交事务，B事务读取了A的修改数据并执行，最后A事务回滚了，这就会造成脏读 丢失修改：1.A事务撤销时，把已经提交的B事务的更新数据覆盖了 A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失 不可重复读：发生在读取了已提交事务的数据，比如A事务第一次读数据时为1000，但是这时候B事务已经修改为900并且提交事务，而A第二次读该数据的时候发现了数据不一致，这就是不可重复读。 幻读：发生在A读取B提交事务新增的数据时，比如A事务第一次读取数据为一条数据，但是这时候B事务已经新增数据且提交事务，而A第二次读了数据不明白造成幻读现象。 1幻象读和不可重复读是两个容易混淆的概念，前者是指读到了其他已经提交事务的新增数据，而后者是指读到了已经提交事务的更改数据（更改或删除），为了避免这两种情况，采取的对策是不同的，防止读取到更改数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生变化，而防止读取到新增数据，则往往需要添加表级锁——将整个表锁定，防止新增数据（Oracle使用多版本数据的方式实现）。 假如要对1亿条数据进行增删改和查询，请给出一个优化建议，没有任何限制，可以添加合适中间件、设置合理的数据库结构等fuck 说一下索引最左匹配原则是什么意思？因为mysql数据库为B+树，B+树是按照从左到右的顺序来建立搜索树的，比如有表含有name、age、set，且为这三个字段建立了联合索引，此时如果查询时按name为第一个查找顺序比如(“张三”,20)时，就会按张三为第一个比较因子查找到张三的数据，然后再往下查20的数据。假设没有name作为查询的第一顺序，比如(20,F)，此时B+树就不知道下一步该查哪个节点，假设为(张三,F)，这时会查找张三的数据，然后查找age的所有数据，然后再查出为f的数据。 Dubbo连接注册中心和直连有什么区别？消息中间件如何解决消息丢失问题？如何保证redis中都是热点数据？Redis缓存穿透、缓存雪崩是什么？如何解决？Zoopkeeper是如何管理分布式锁的（节点层面出发）Zoopkeeper是如何管理集群状态的（节点层面出发）Dubbo的底层实现原理和机制事务tranciationBean是单例的吗？controller是不是线程安全数据库优化redis是单例的，为什么性能很高？mysql（oracle）varchar和char的区别是什么？Sql语句执行是从后向前的？原理？SpringMVC的执行原理，具体细节？","link":"/2020/01/02/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"生活记录","slug":"生活记录","link":"/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}